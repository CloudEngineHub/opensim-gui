/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  This muscle model was published in Meyer et al. 2016. The implementation is<br>
 * based heavily on the previously implemented DeGrooteFregly2016Muscle.<br>
 * <br>
 * This is a rigid-tendon muscle model. Therefore, the ignore_tendon_compliance<br>
 * property is ignored, and a warning is issued if it is set to false. In the<br>
 * Muscle class setIngoreActivationDynamics() controls a modeling option, meaning<br>
 * this settings could theoretically be changed. However, for this class, the<br>
 * modeling option is ignored and the value of the ignore_activation_dynamics<br>
 * property is used directly.<br>
 * <br>
 * This implementation introduces the property 'active_force_width_scale' as<br>
 * an addition to the original model, which allows users to effectively make<br>
 * the active force-length curve wider. This property may be useful for<br>
 * improving the force-generating capacity of a muscle without increasing<br>
 * maximum isometric force. This property works by scaling the normalized<br>
 * fiber length when the active force-length curve is computed. For example,<br>
 * a scale factor of 2 means that the fiber muscle traverses half as far<br>
 * along the force-length curve in either direction.<br>
 * <br>
 * This implementation adds fiber damping as an addition to the original model.<br>
 * Users can specify this via the 'fiber_damping' property, and damping force<br>
 * along the fiber is computed by multiplying the property value by the<br>
 * normalized fiber velocity and max isometric force. If using this muscle for<br>
 * optimization, fiber damping is recommended as it can improve convergence.<br>
 * <br>
 * <br>
 * The acceptable bounds for each property are enforced at model initialization.<br>
 * These bounds are:<br>
 *  - activation_time_constant: (0, inf]<br>
 *  - deactivation_time_constant: (0, inf]<br>
 *  - activation_dynamics_smoothing: (0, inf]<br>
 *  - active_force_width_scale: [1, inf]<br>
 *  - fiber_damping: [0, inf]<br>
 *  - pennation_angle_at_optimal: [0, Pi/2)<br>
 *  - default_activation: (0, inf]<br>
 * <br>
 * Note: The default value for activation_dynamics_smoothing is set to 0.1 to<br>
 *       match the originally published model, but a value of 10 is recommended<br>
 *       to achieve activation and deactivation speeds closer to the intended<br>
 *       time constants.<br>
 * <br>
 * Note: Muscle properties can be optimized using MocoParameter. The acceptable<br>
 * bounds for each property are **not** enforced during parameter optimization, so<br>
 * the user must supply these bounds to MocoParameter.<br>
 * <br>
 * Note: The properties `default_activation` and `default_normalized_tendon_force`<br>
 * cannot be optimized because they are applied during model initialization only.<br>
 * <br>
 * <br>
 * <br>
 * The documentation for Muscle::MuscleLengthInfo states that the<br>
 * optimalFiberLength of a muscle is also its resting length, but this is not<br>
 * true for this muscle: there is a non-zero passive fiber force at the<br>
 * optimal fiber length.<br>
 * <br>
 * Meyer A. J., Eskinazi, I., Jackson, J. N., Rao, A. V., Patten, C., &amp; Fregly,<br>
 * B. J. (2016). Muscle Synergies Facilitate Computational Prediction of<br>
 * Subject-Specific Walking Motions. Frontiers in Bioengineering and<br>
 * Biotechnology, 4, 1055â€“27. http://doi.org/10.3389/fbioe.2016.00077 
 */
public class MeyerFregly2016Muscle extends Muscle {
  private transient long swigCPtr;

  public MeyerFregly2016Muscle(long cPtr, boolean cMemoryOwn) {
    super(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(MeyerFregly2016Muscle obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(MeyerFregly2016Muscle obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimActuatorsAnalysesToolsJNI.delete_MeyerFregly2016Muscle(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static MeyerFregly2016Muscle safeDownCast(OpenSimObject obj) {
    long cPtr = opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new MeyerFregly2016Muscle(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new MeyerFregly2016Muscle(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_getConcreteClassName(swigCPtr, this);
  }

  public void copyProperty_activation_time_constant(MeyerFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_copyProperty_activation_time_constant(swigCPtr, this, MeyerFregly2016Muscle.getCPtr(source), source);
  }

  public double get_activation_time_constant(int i) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_activation_time_constant__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_activation_time_constant(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_activation_time_constant__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_activation_time_constant(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_activation_time_constant__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_activation_time_constant(double value) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_append_activation_time_constant(swigCPtr, this, value);
  }

  public void constructProperty_activation_time_constant(double initValue) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_constructProperty_activation_time_constant(swigCPtr, this, initValue);
  }

  public double get_activation_time_constant() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_activation_time_constant__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_activation_time_constant() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_activation_time_constant__SWIG_1(swigCPtr, this), false);
  }

  public void set_activation_time_constant(double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_activation_time_constant__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_deactivation_time_constant(MeyerFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_copyProperty_deactivation_time_constant(swigCPtr, this, MeyerFregly2016Muscle.getCPtr(source), source);
  }

  public double get_deactivation_time_constant(int i) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_deactivation_time_constant__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_deactivation_time_constant(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_deactivation_time_constant__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_deactivation_time_constant(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_deactivation_time_constant__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_deactivation_time_constant(double value) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_append_deactivation_time_constant(swigCPtr, this, value);
  }

  public void constructProperty_deactivation_time_constant(double initValue) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_constructProperty_deactivation_time_constant(swigCPtr, this, initValue);
  }

  public double get_deactivation_time_constant() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_deactivation_time_constant__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_deactivation_time_constant() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_deactivation_time_constant__SWIG_1(swigCPtr, this), false);
  }

  public void set_deactivation_time_constant(double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_deactivation_time_constant__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_default_activation(MeyerFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_copyProperty_default_activation(swigCPtr, this, MeyerFregly2016Muscle.getCPtr(source), source);
  }

  public double get_default_activation(int i) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_default_activation__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_default_activation(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_default_activation__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_default_activation(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_default_activation__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_default_activation(double value) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_append_default_activation(swigCPtr, this, value);
  }

  public void constructProperty_default_activation(double initValue) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_constructProperty_default_activation(swigCPtr, this, initValue);
  }

  public double get_default_activation() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_default_activation__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_default_activation() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_default_activation__SWIG_1(swigCPtr, this), false);
  }

  public void set_default_activation(double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_default_activation__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_active_force_width_scale(MeyerFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_copyProperty_active_force_width_scale(swigCPtr, this, MeyerFregly2016Muscle.getCPtr(source), source);
  }

  public double get_active_force_width_scale(int i) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_active_force_width_scale__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_active_force_width_scale(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_active_force_width_scale__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_active_force_width_scale(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_active_force_width_scale__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_active_force_width_scale(double value) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_append_active_force_width_scale(swigCPtr, this, value);
  }

  public void constructProperty_active_force_width_scale(double initValue) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_constructProperty_active_force_width_scale(swigCPtr, this, initValue);
  }

  public double get_active_force_width_scale() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_active_force_width_scale__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_active_force_width_scale() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_active_force_width_scale__SWIG_1(swigCPtr, this), false);
  }

  public void set_active_force_width_scale(double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_active_force_width_scale__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_fiber_damping(MeyerFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_copyProperty_fiber_damping(swigCPtr, this, MeyerFregly2016Muscle.getCPtr(source), source);
  }

  public double get_fiber_damping(int i) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_fiber_damping__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_fiber_damping(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_fiber_damping__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_fiber_damping(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_fiber_damping__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_fiber_damping(double value) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_append_fiber_damping(swigCPtr, this, value);
  }

  public void constructProperty_fiber_damping(double initValue) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_constructProperty_fiber_damping(swigCPtr, this, initValue);
  }

  public double get_fiber_damping() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_fiber_damping__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_fiber_damping() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_fiber_damping__SWIG_1(swigCPtr, this), false);
  }

  public void set_fiber_damping(double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_fiber_damping__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_ignore_passive_fiber_force(MeyerFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_copyProperty_ignore_passive_fiber_force(swigCPtr, this, MeyerFregly2016Muscle.getCPtr(source), source);
  }

  public boolean get_ignore_passive_fiber_force(int i) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_ignore_passive_fiber_force__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_ignore_passive_fiber_force(int i) {
    return new SWIGTYPE_p_bool(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_ignore_passive_fiber_force__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_ignore_passive_fiber_force(int i, boolean value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_ignore_passive_fiber_force__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_ignore_passive_fiber_force(boolean value) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_append_ignore_passive_fiber_force(swigCPtr, this, value);
  }

  public void constructProperty_ignore_passive_fiber_force(boolean initValue) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_constructProperty_ignore_passive_fiber_force(swigCPtr, this, initValue);
  }

  public boolean get_ignore_passive_fiber_force() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_ignore_passive_fiber_force__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_ignore_passive_fiber_force() {
    return new SWIGTYPE_p_bool(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_ignore_passive_fiber_force__SWIG_1(swigCPtr, this), false);
  }

  public void set_ignore_passive_fiber_force(boolean value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_ignore_passive_fiber_force__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_activation_dynamics_smoothing(MeyerFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_copyProperty_activation_dynamics_smoothing(swigCPtr, this, MeyerFregly2016Muscle.getCPtr(source), source);
  }

  public double get_activation_dynamics_smoothing(int i) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_activation_dynamics_smoothing__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_activation_dynamics_smoothing(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_activation_dynamics_smoothing__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_activation_dynamics_smoothing(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_activation_dynamics_smoothing__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_activation_dynamics_smoothing(double value) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_append_activation_dynamics_smoothing(swigCPtr, this, value);
  }

  public void constructProperty_activation_dynamics_smoothing(double initValue) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_constructProperty_activation_dynamics_smoothing(swigCPtr, this, initValue);
  }

  public double get_activation_dynamics_smoothing() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_get_activation_dynamics_smoothing__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_activation_dynamics_smoothing() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_upd_activation_dynamics_smoothing__SWIG_1(swigCPtr, this), false);
  }

  public void set_activation_dynamics_smoothing(double value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_set_activation_dynamics_smoothing__SWIG_1(swigCPtr, this, value);
  }

  public void set_has_output_passive_fiber_elastic_force(boolean value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle__has_output_passive_fiber_elastic_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_elastic_force() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle__has_output_passive_fiber_elastic_force_get(swigCPtr, this);
  }

  public void set_has_output_passive_fiber_elastic_force_along_tendon(boolean value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle__has_output_passive_fiber_elastic_force_along_tendon_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_elastic_force_along_tendon() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle__has_output_passive_fiber_elastic_force_along_tendon_get(swigCPtr, this);
  }

  public void set_has_output_passive_fiber_damping_force(boolean value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle__has_output_passive_fiber_damping_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_damping_force() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle__has_output_passive_fiber_damping_force_get(swigCPtr, this);
  }

  public void set_has_output_passive_fiber_damping_force_along_tendon(boolean value) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle__has_output_passive_fiber_damping_force_along_tendon_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_damping_force_along_tendon() {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle__has_output_passive_fiber_damping_force_along_tendon_get(swigCPtr, this);
  }

  public MeyerFregly2016Muscle() {
    this(opensimActuatorsAnalysesToolsJNI.new_MeyerFregly2016Muscle(), true);
  }

  /**
   *  <br>
   *  If ignore_activation_dynamics is true, this gets excitation instead.
   */
  public double getActivation(State arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_getActivation(swigCPtr, this, State.getCPtr(arg0), arg0);
  }

  /**
   *  If ignore_activation_dynamics is true, this sets excitation instead.
   */
  public void setActivation(State arg0, double arg1) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_setActivation(swigCPtr, this, State.getCPtr(arg0), arg0, arg1);
  }

  public double calcMuscleStiffness(State arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcMuscleStiffness__SWIG_0(swigCPtr, this, State.getCPtr(arg0), arg0);
  }

  public void computeInitialFiberEquilibrium(State arg0) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_computeInitialFiberEquilibrium(swigCPtr, this, State.getCPtr(arg0), arg0);
  }

  /**
   *  <br>
   *  <br>
   *  Get the portion of the passive fiber force generated by the elastic<br>
   *  element only.
   */
  public double getPassiveFiberElasticForce(State arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_getPassiveFiberElasticForce(swigCPtr, this, State.getCPtr(arg0), arg0);
  }

  /**
   *  Get the portion of the passive fiber force generated by the elastic<br>
   *  element only, projected onto the tendon direction.
   */
  public double getPassiveFiberElasticForceAlongTendon(State arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_getPassiveFiberElasticForceAlongTendon(swigCPtr, this, State.getCPtr(arg0), arg0);
  }

  /**
   *  Get the portion of the passive fiber force generated by the damping<br>
   *  element only.
   */
  public double getPassiveFiberDampingForce(State arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_getPassiveFiberDampingForce(swigCPtr, this, State.getCPtr(arg0), arg0);
  }

  /**
   *  Get the portion of the passive fiber force generated by the damping<br>
   *  element only, projected onto the tendon direction.
   */
  public double getPassiveFiberDampingForceAlongTendon(State arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_getPassiveFiberDampingForceAlongTendon(swigCPtr, this, State.getCPtr(arg0), arg0);
  }

  /**
   *  The first element of the Vec2 is the lower bound, and the second is the<br>
   *  upper bound.<br>
   *  Note that since fiber length is not used as a state variable, these<br>
   *  bounds cannot be enforced directly. It is upon the user to ensure the<br>
   *  muscle fiber is operating within the specified domain.
   */
  public Vec2 getBoundsNormalizedFiberLength() {
    return new Vec2(opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_getBoundsNormalizedFiberLength(swigCPtr, this), true);
  }

  /**
   *  <br>
   *  These functions compute the values of normalized/dimensionless curves,<br>
   *  their derivatives and integrals, and other quantities of the muscle.<br>
   *  These do not depend on a SimTK::State.<br>
   *  <br>
   *  The active force-length curve is the sum of 3 Gaussian-like curves. The<br>
   *  width of the curve can be adjusted via the 'active_force_width_scale'<br>
   *  property.
   */
  public double calcActiveForceLengthMultiplier(double arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcActiveForceLengthMultiplier(swigCPtr, this, arg0);
  }

  /**
   *  The derivative of the active force-length curve with respect to<br>
   *  normalized fiber length. This curve is based on the derivative of the<br>
   *  Gaussian-like curve used in calcActiveForceLengthMultiplier(). The<br>
   *  'active_force_width_scale' property also affects the value of the<br>
   *  derivative curve.
   */
  public double calcActiveForceLengthMultiplierDerivative(double arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcActiveForceLengthMultiplierDerivative(swigCPtr, this, arg0);
  }

  /**
   *  The parameters of this curve are not modifiable, so this function is<br>
   *  static.<br>
   *  Note: It is upon the user to check that the muscle fiber is acting<br>
   *        within the specified domain. Force computations outside this range<br>
   *        may be incorrect.
   */
  public static double calcForceVelocityMultiplier(double arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcForceVelocityMultiplier(arg0);
  }

  /**
   *  This is the inverse of the force-velocity multiplier function, and<br>
   *  returns the normalized fiber velocity (in [-1, 1]) as a function of<br>
   *  the force-velocity multiplier.
   */
  public static double calcForceVelocityInverseCurve(double arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcForceVelocityInverseCurve(arg0);
  }

  /**
   *  This is the passive force-length curve. The curve becomes negative below<br>
   *  the minNormFiberLength.
   */
  public double calcPassiveForceMultiplier(double arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcPassiveForceMultiplier(swigCPtr, this, arg0);
  }

  /**
   *  This is the derivative of the passive force-length curve with respect to<br>
   *  the normalized fiber length.
   */
  public double calcPassiveForceMultiplierDerivative(double arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcPassiveForceMultiplierDerivative(swigCPtr, this, arg0);
  }

  /**
   *  This is the integral of the passive force-length curve with respect to<br>
   *  the normalized fiber length over the domain<br>
   *  [minNormFiberLength normFiberLength], where minNormFiberLength is the<br>
   *  value return by getMinNormalizedFiberLength().<br>
   * <br>
   *  This placeholder implementation returns zero.
   */
  public double calcPassiveForceMultiplierIntegral(double arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcPassiveForceMultiplierIntegral(swigCPtr, this, arg0);
  }

  /**
   *  This computes both the total fiber force and the individual components<br>
   *  of fiber force (active, conservative passive, and non-conservative<br>
   *  passive).<br>
   *  Note: based on Millard2012EquilibriumMuscle::calcFiberForce().
   */
  public void calcFiberForce(double activation, double activeForceLengthMultiplier, double forceVelocityMultiplier, double normPassiveFiberForce, double normFiberVelocity, SWIGTYPE_p_double activeFiberForce, SWIGTYPE_p_double conPassiveFiberForce, SWIGTYPE_p_double nonConPassiveFiberForce, SWIGTYPE_p_double totalFiberForce) {
    opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcFiberForce(swigCPtr, this, activation, activeForceLengthMultiplier, forceVelocityMultiplier, normPassiveFiberForce, normFiberVelocity, SWIGTYPE_p_double.getCPtr(activeFiberForce), SWIGTYPE_p_double.getCPtr(conPassiveFiberForce), SWIGTYPE_p_double.getCPtr(nonConPassiveFiberForce), SWIGTYPE_p_double.getCPtr(totalFiberForce));
  }

  /**
   *  The stiffness of the fiber in the direction of the fiber. This includes<br>
   *  both active and passive force contributions to stiffness from the muscle<br>
   *  fiber.<br>
   *  Note: based on Millard2012EquilibriumMuscle::calcFiberStiffness().
   */
  public double calcFiberStiffness(double activation, double normFiberLength, double fiberVelocityMultiplier) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcFiberStiffness(swigCPtr, this, activation, normFiberLength, fiberVelocityMultiplier);
  }

  /**
   *  The stiffness of the whole musculotendon unit in the direction of the<br>
   *  tendon.<br>
   * <br>
   *  Note: The default implementation includes additional checks that<br>
   *  the stiffness is non-negative and that the denominator is non-zero.<br>
   *  Checks are omitted here to preserve continuity and smoothness for<br>
   *  optimization (see #3685).
   */
  public double calcMuscleStiffness(double tendonStiffness, double fiberStiffnessAlongTendon) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcMuscleStiffness__SWIG_1(swigCPtr, this, tendonStiffness, fiberStiffnessAlongTendon);
  }

  /**
   *  The derivative of pennation angle with respect to fiber length.<br>
   *  Note: based on<br>
   *  MuscleFixedWidthPennationModel::calc_DPennationAngle_DFiberLength().
   */
  public double calcPartialPennationAnglePartialFiberLength(double arg0) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcPartialPennationAnglePartialFiberLength(swigCPtr, this, arg0);
  }

  /**
   *  The derivative of the fiber force along the tendon with respect to fiber<br>
   *  length.<br>
   *  Note: based on<br>
   *  Millard2012EquilibriumMuscle::calc_DFiberForceAT_DFiberLength().
   */
  public double calcPartialFiberForceAlongTendonPartialFiberLength(double fiberForce, double fiberStiffness, double sinPennationAngle, double cosPennationAngle, double partialPennationAnglePartialFiberLength) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcPartialFiberForceAlongTendonPartialFiberLength(swigCPtr, this, fiberForce, fiberStiffness, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength);
  }

  /**
   *  The derivative of the fiber force along the tendon with respect to the<br>
   *  fiber length along the tendon.<br>
   *  Note: based on<br>
   *  Millard2012EquilibriumMuscle::calc_DFiberForceAT_DFiberLengthAT.
   */
  public double calcFiberStiffnessAlongTendon(double fiberLength, double partialFiberForceAlongTendonPartialFiberLength, double sinPennationAngle, double cosPennationAngle, double partialPennationAnglePartialFiberLength) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcFiberStiffnessAlongTendon(swigCPtr, this, fiberLength, partialFiberForceAlongTendonPartialFiberLength, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength);
  }

  /**
   *  The derivative of the tendon length with respect to the fiberlength.
   */
  public double calcPartialTendonLengthPartialFiberLength(double fiberLength, double sinPennationAngle, double cosPennationAngle, double partialPennationAnglePartialFiberLength) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcPartialTendonLengthPartialFiberLength(swigCPtr, this, fiberLength, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength);
  }

  /**
   *  The derivative of the tendon force with respect to the fiber length.
   */
  public double calcPartialTendonForcePartialFiberLength(double tendonStiffness, double fiberLength, double sinPennationAngle, double cosPennationAngle) {
    return opensimActuatorsAnalysesToolsJNI.MeyerFregly2016Muscle_calcPartialTendonForcePartialFiberLength(swigCPtr, this, tendonStiffness, fiberLength, sinPennationAngle, cosPennationAngle);
  }

}
