/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * <br>
 * A concrete class representing a geometric path object defined by a list of<br>
 * path points and wrapping obstacles.<br>
 * <br>
 * The path consists of straight line segments and curved line segments: a<br>
 * curved segment over each obstacle, and straight segments connecting path<br>
 * points to obstacles. If no obstacle lies between two path points, the points<br>
 * will be connected by a straight line segment. The path is computed as a<br>
 * geodesic to provide a shortest path over the surface. During a simulation,<br>
 * the cable can slide freely over the obstacle surfaces. It can lose contact<br>
 * with a surface and miss that obstacle in a straight line. Similarly the cable<br>
 * can touchdown on the obstacle if the surface obstructs the straight line<br>
 * segment again.<br>
 * <br>
 * The path is computed as an optimization problem using the previous optimal<br>
 * path as the warm start. This is done by computing natural geodesic<br>
 * corrections for each curve segment to compute the locally shortest path,<br>
 * as described in the following publication:<br>
 * <br>
 *     Scholz, A., Sherman, M., Stavness, I. et al (2015). A fast multi-obstacle<br>
 *     muscle wrapping method using natural geodesic variations. Multibody<br>
 *     System Dynamics 36, 195â€“219.<br>
 * <br>
 * The overall path is locally the shortest, allowing winding over an obstacle<br>
 * multiple times, without flipping to the other side.<br>
 * <br>
 * This class encapsulates `SimTK::CableSpan`, the Simbody implementation of<br>
 * this algorithm. For the full details concerning this class, see the Simbody<br>
 * API documentation.<br>
 * <br>
 * ## Constructing a Scholz2015GeometryPath<br>
 * <br>
 * The simplest valid path consists of two path points: an origin and an<br>
 * insertion point:<br>
 * <br>
 * {@code 
Model model = ModelFactory::createDoublePendulum();
Scholz2015GeometryPath* path = new Scholz2015GeometryPath();
path.appendPathPoint(model.getGround(), SimTK::Vec3(0.05, 0.05, 0.));
path.appendPathPoint(model.getComponent<Body>("/bodyset/b0"),
        SimTK::Vec3(-0.5, 0.1, 0.));
model.addComponent(path);
}<br>
 * <br>
 * Typically, a Scholz2015GeometryPath will be used to define the geometry of<br>
 * path-based force generating elements, e.g., `PathSpring`, `PathActuator`,<br>
 * `Muscle`, etc. This example shows how to create a `PathSpring` and set the<br>
 * 'path' property to a Scholz2015GeometryPath:<br>
 * <br>
 * {@code 
auto* spring = new PathSpring();
spring->setName("path_spring");
spring->setRestingLength(0.25);
spring->setDissipation(0.75);
spring->setStiffness(10.0);
spring->set_path(Scholz2015GeometryPath());
model.addComponent(spring);

auto& path = spring->updPath<Scholz2015GeometryPath>();
path.setName("path");
path.appendPathPoint(model.getGround(), SimTK::Vec3(0.05, 0.05, 0));
path.appendPathPoint(model.getComponent<Body>("/bodyset/b1"),
        SimTK::Vec3(-0.25, 0.1, 0));
}<br>
 * <br>
 * Note: We append path points *after* the `Scholz2015GeometryPath` has been<br>
 * added to the `PathSpring`, so that the connections for each `PathPoint`'s<br>
 * parent frame `Socket` remain valid. If we instead called `set_path()` after<br>
 * each `PathPoint` was appended, the `Socket` connections would be broken when<br>
 * the `Scholz2015GeometryPath` is copied into the `PathSpring`.<br>
 * <br>
 * ## Appending Wrap Obstacles<br>
 * <br>
 * Wrap obstacles are defined by `ContactGeometry` objects which encapsulate<br>
 * a wrapping geometry, the `PhysicalFrame` that the geometry is attached to,<br>
 * and the location and orientation of the geometry in that frame. The following<br>
 * concrete implementations of `ContactGeometry` are recommended for use with<br>
 * `Scholz2015GeometryPath`:<br>
 * - `ContactSphere`<br>
 * - `ContactCylinder`<br>
 * - `ContactEllipsoid`<br>
 * - `ContactTorus`<br>
 * <br>
 * Use `appendObstacle()` to append a `ContactGeometry` wrapping obstacle to<br>
 * path, along with a "contact hint" that is used to initialize the wrapping<br>
 * solver:<br>
 * <br>
 * {@code 
auto* obstacle = new ContactCylinder(0.15,
        SimTK::Vec3(-0.2, 0.2, 0), SimTK::Vec3(0),
        model.getComponent<Body>("/bodyset/b0"));
model.addComponent(obstacle);
path.appendObstacle(*obstacle, SimTK::Vec3(0., 0.15, 0.));
}<br>
 * <br>
 * The contact hint is a `SimTK::Vec3` defining a point on the surface in local<br>
 * surface frame coordinates. The point will be used to provide an initial guess<br>
 * when solving for the path. As such, it does not have to lie on the contact<br>
 * geometry's surface, nor does it have to belong to a valid cable path. For<br>
 * obstacles with symmetry, the choice of the contact hint will determine which<br>
 * side of the obstacle the path will wrap around.<br>
 * <br>
 * A `Scholz2015GeometryPath` must begin and end with a path point. Since we<br>
 * appended an obstacle, we must append an additional path point to "close" the<br>
 * path:<br>
 * <br>
 * {@code 
path.appendPathPoint(model.getComponent<Body>("/bodyset/b1"),
        SimTK::Vec3(-0.5, 0.1, 0.));
}<br>
 * <br>
 * ## Path Ordering<br>
 * <br>
 * The order in which obstacles and path points are appended to the path is<br>
 * important. For example, consider the path we constructed above:<br>
 * <br>
 * {@code 
path.appendPathPoint(model.getGround(), SimTK::Vec3(0.05, 0.05, 0.));
path.appendPathPoint(model.getComponent<Body>("/bodyset/b0"),
        SimTK::Vec3(-0.5, 0.1, 0.));
path.appendObstacle(*obstacle, SimTK::Vec3(0., 0.15, 0.));
path.appendPathPoint(model.getComponent<Body>("/bodyset/b1"),
        SimTK::Vec3(-0.5, 0.1, 0.));
}<br>
 * <br>
 * Using the order of calls above, we have explicitly defined a cylinder<br>
 * obstacle to apply only to the portion of the path between the second and<br>
 * third path points.<br>
 * <br>
 * By changing the order of the `appendObstacle()` and `appendPathPoint()`<br>
 * calls, we could define a different path where a cylinder obstacle is applied<br>
 * to the portion of the path between the first and second path points:<br>
 * <br>
 * {@code 
path.appendPathPoint(model.getGround(), SimTK::Vec3(0.05, 0.05, 0.));
path.appendObstacle(*obstacle, SimTK::Vec3(0., 0.15, 0.));
path.appendPathPoint(model.getComponent<Body>("/bodyset/b0"),
        SimTK::Vec3(-0.5, 0.1, 0.));
path.appendPathPoint(model.getComponent<Body>("/bodyset/b1"),
        SimTK::Vec3(-0.5, 0.1, 0.));
}<br>
 * <br>
 * The location of the cylinder obstacle in this new path would likely need to<br>
 * be updated to a new location that is consistent with the portion of the path<br>
 * between the first and second path points to produce the desired wrapping<br>
 * behavior. Note also that both of the path examples above are valid, since<br>
 * each begins and ends with a path point.<br>
 * <br>
 * ## Changing Obstacle Properties<br>
 * <br>
 * The properties of a `ContactGeometry` obstacle can be changed after it has<br>
 * been appended to the path. However, if `ContactGeometry` properties are<br>
 * changed, you must both rebuild the system *and* generate a new `SimTK::State`<br>
 * in order for the change to take effect. For example, the following code shows<br>
 * how to change the radius of a `ContactCylinder` obstacle and compute the new<br>
 * path length:<br>
 * <br>
 * {@code 
model.updComponent<ContactCylinder>("/cylinder").setRadius(0.2);
SimTK::State state = model.initSystem();
model.realizePosition(state);
SimTK::Real length = path.getLength(state);
}<br>
 * <br>
 * Note: A new `SimTK::State` must be generated because changing<br>
 * `ContactGeometry` properties will not invalidate the `SimTK::State` cache.<br>
 * Reusing a previous `SimTK::State` with `path.getLength(state)` will return<br>
 * the cached (and likely incorrect) path length value computed prior to the<br>
 * property change.<br>
 * <br>
 * @see Scholz2015GeometryPathPoint<br>
 * @see Scholz2015GeometryPathObstacle
 */
public class Scholz2015GeometryPath extends AbstractGeometryPath {
  private transient long swigCPtr;

  public Scholz2015GeometryPath(long cPtr, boolean cMemoryOwn) {
    super(opensimSimulationJNI.Scholz2015GeometryPath_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(Scholz2015GeometryPath obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(Scholz2015GeometryPath obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_Scholz2015GeometryPath(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static Scholz2015GeometryPath safeDownCast(OpenSimObject obj) {
    long cPtr = opensimSimulationJNI.Scholz2015GeometryPath_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new Scholz2015GeometryPath(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimSimulationJNI.Scholz2015GeometryPath_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimSimulationJNI.Scholz2015GeometryPath_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimSimulationJNI.Scholz2015GeometryPath_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new Scholz2015GeometryPath(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimSimulationJNI.Scholz2015GeometryPath_getConcreteClassName(swigCPtr, this);
  }

  /**
   *  Default constructor. 
   */
  public Scholz2015GeometryPath() {
    this(opensimSimulationJNI.new_Scholz2015GeometryPath(), true);
  }

  /**
   * Append a path point to the path.
   */
  public void appendPathPoint(PhysicalFrame frame, Vec3 location) {
    opensimSimulationJNI.Scholz2015GeometryPath_appendPathPoint(swigCPtr, this, PhysicalFrame.getCPtr(frame), frame, Vec3.getCPtr(location), location);
  }

  /**
   * Get the origin `PathPoint` of the path (i.e., the first path point).
   */
  public PathPoint getOrigin() {
    return new PathPoint(opensimSimulationJNI.Scholz2015GeometryPath_getOrigin(swigCPtr, this), false);
  }

  /**
   * Get the insertion `PathPoint` of the path (i.e., the last path point).
   */
  public PathPoint getInsertion() {
    return new PathPoint(opensimSimulationJNI.Scholz2015GeometryPath_getInsertion(swigCPtr, this), false);
  }

  /**
   * Get the `PathPoint` at the specified index.<br>
   * <br>
   * The argument `pathPointIndex` is the index to the list of path points in<br>
   * the path, not all path elements (e.g., obstacles). For example, if the<br>
   * path consists of two path points and one obstacle, the valid indices are<br>
   * 0 and 1.<br>
   * <br>
   * Note: Avoid repeated calls to this method in performance-critical<br>
   * code, as it may involve searching through the path elements.
   */
  public PathPoint getPathPoint(int pathPointIndex) {
    return new PathPoint(opensimSimulationJNI.Scholz2015GeometryPath_getPathPoint(swigCPtr, this, pathPointIndex), false);
  }

  /**
   * Add an obstacle to the path.<br>
   * <br>
   * The contact hint is a `SimTK::Vec3` defining a point on the surface, in<br>
   * the surface coordinates, used to initialize the wrapping solver. The<br>
   * contact hint need not lie on the surface, nor does it need to belong to a<br>
   * valid wrapping path.<br>
   * <br>
   * @param contactGeometry  the ContactGeometry representing the obstacle.<br>
   * @param contactHint      the point on the contact geometry surface, in<br>
   *                         surface coordinates, that is used to initialize<br>
   *                         the wrapping solver.<br>
   * <br>
   * @see Scholz2015GeometryPathObstacle
   */
  public void appendObstacle(ContactGeometry contactGeometry, Vec3 contactHint) {
    opensimSimulationJNI.Scholz2015GeometryPath_appendObstacle(swigCPtr, this, ContactGeometry.getCPtr(contactGeometry), contactGeometry, Vec3.getCPtr(contactHint), contactHint);
  }

  /**
   * Get the `ContactGeometry` associated with the obstacle at the specified<br>
   * index.<br>
   * <br>
   * The argument `obstacleIndex` is the index to the list of obstacles in<br>
   * the path, not all path elements (e.g., path points). For example, if the<br>
   * path consists of two path points and one obstacle, the only valid index<br>
   * is 0.<br>
   * <br>
   * Note: Avoid repeated calls to this method in performance-critical<br>
   * code, as it may involve searching through the path elements.
   */
  public ContactGeometry getContactGeometry(int obstacleIndex) {
    return new ContactGeometry(opensimSimulationJNI.Scholz2015GeometryPath_getContactGeometry(swigCPtr, this, obstacleIndex), false);
  }

  /**
   * Get the contact hint associated with the obstacle at the specified<br>
   * index.<br>
   * <br>
   * The argument `obstacleIndex` is the index to the list of obstacles in<br>
   * the path, not all path elements (e.g., path points). For example, if the<br>
   * path consists of two path points and one obstacle, the only valid index<br>
   * is 0.<br>
   * <br>
   * Note: Avoid repeated calls to this method in performance-critical<br>
   * code, as it may involve searching through the path elements.
   */
  public Vec3 getContactHint(int obstacleIndex) {
    return new Vec3(opensimSimulationJNI.Scholz2015GeometryPath_getContactHint(swigCPtr, this, obstacleIndex), false);
  }

  /**
   * Get the number of path points in the path.
   */
  public int getNumPathPoints() {
    return opensimSimulationJNI.Scholz2015GeometryPath_getNumPathPoints(swigCPtr, this);
  }

  /**
   * Get the number of obstacles in the path.
   */
  public int getNumObstacles() {
    return opensimSimulationJNI.Scholz2015GeometryPath_getNumObstacles(swigCPtr, this);
  }

  /**
   * Get the total number of path elements (path points and obstacles) in the<br>
   * path.
   */
  public int getNumPathElements() {
    return opensimSimulationJNI.Scholz2015GeometryPath_getNumPathElements(swigCPtr, this);
  }

  public double getLength(State s) {
    return opensimSimulationJNI.Scholz2015GeometryPath_getLength(swigCPtr, this, State.getCPtr(s), s);
  }

  public double getLengtheningSpeed(State s) {
    return opensimSimulationJNI.Scholz2015GeometryPath_getLengtheningSpeed(swigCPtr, this, State.getCPtr(s), s);
  }

  public double computeMomentArm(State s, Coordinate coord) {
    return opensimSimulationJNI.Scholz2015GeometryPath_computeMomentArm(swigCPtr, this, State.getCPtr(s), s, Coordinate.getCPtr(coord), coord);
  }

  public boolean isVisualPath() {
    return opensimSimulationJNI.Scholz2015GeometryPath_isVisualPath(swigCPtr, this);
  }

  public void produceForces(State s, double tension, SWIGTYPE_p_OpenSim__ForceConsumer consumer) {
    opensimSimulationJNI.Scholz2015GeometryPath_produceForces(swigCPtr, this, State.getCPtr(s), s, tension, SWIGTYPE_p_OpenSim__ForceConsumer.getCPtr(consumer));
  }

}
